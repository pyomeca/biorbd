// File : biorbd_python.i

// Declare the Python specific interface
%{
#define SWIG_FILE_WITH_INIT
#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION
#include "Python.h"

#include "numpy/arrayobject.h"

#include "BiorbdModel.h"
#include "Utils/Matrix.h"
#include "Utils/Vector3d.h"
#include "Utils/Matrix3d.h"
#include "RigidBody/GeneralizedCoordinates.h"
#include "RigidBody/GeneralizedVelocity.h"
#include "RigidBody/GeneralizedAcceleration.h"
#include "RigidBody/GeneralizedTorque.h"
#include "RigidBody/IMU.h"
%}

%include "@CMAKE_CURRENT_SOURCE_DIR@/numpy.i"
%init %{
    import_array();
%}

%include "@CMAKE_BINARY_DIR@/include/biorbdConfig.h"


#if defined(BIORBD_USE_CASADI_MATH)
#define SWIG_UTILS_STRING SWIGTYPE_p_BiorbdCasadi__utils__String
#define SWIG_UTILS_PATH SWIGTYPE_p_BiorbdCasadi__utils__Path
#define SWIG_UTILS_MATRIX3D SWIGTYPE_p_BiorbdCasadi__utils__Matrix3d
#define SWIG_UTILS_VECTOR SWIGTYPE_p_BiorbdCasadi__utils__Vector
#define SWIG_UTILS_NODE SWIGTYPE_p_BiorbdCasadi__utils__Node
#define SWIG_UTILS_VECTOR3D SWIGTYPE_p_BiorbdCasadi__utils__Vector3d
#define SWIG_UTILS_SPATIAL_VECTOR SWIGTYPE_p_BiorbdCasadi__utils__SpatialVector

#define SWIG_RIGIDBODY_JOINTS SWIGTYPE_p_BiorbdCasadi__rigidbody__Joints
#define SWIG_RIGIDBODY_GEN_COORD SWIGTYPE_p_BiorbdCasadi__rigidbody__GeneralizedCoordinates
#define SWIG_RIGIDBODY_GEN_VEL SWIGTYPE_p_BiorbdCasadi__rigidbody__GeneralizedVelocity
#define SWIG_RIGIDBODY_GEN_ACC SWIGTYPE_p_BiorbdCasadi__rigidbody__GeneralizedAcceleration
#define SWIG_RIGIDBODY_GEN_TORQUE SWIGTYPE_p_BiorbdCasadi__rigidbody__GeneralizedTorque
#define SWIG_RIGIDBODY_MARKERS SWIGTYPE_p_BiorbdCasadi__rigidbody__Markers

#elif defined(BIORBD_USE_EIGEN3_MATH)
#define SWIG_UTILS_STRING SWIGTYPE_p_BiorbdEigen3__utils__String
#define SWIG_UTILS_PATH SWIGTYPE_p_BiorbdEigen3__utils__Path
#define SWIG_UTILS_MATRIX3D SWIGTYPE_p_BiorbdEigen3__utils__Matrix3d
#define SWIG_UTILS_VECTOR SWIGTYPE_p_BiorbdEigen3__utils__Vector
#define SWIG_UTILS_NODE SWIGTYPE_p_BiorbdEigen3__utils__Node
#define SWIG_UTILS_VECTOR3D SWIGTYPE_p_BiorbdEigen3__utils__Vector3d
#define SWIG_UTILS_SPATIAL_VECTOR SWIGTYPE_p_BiorbdEigen3__utils__SpatialVector

#define SWIG_RIGIDBODY_JOINTS SWIGTYPE_p_BiorbdEigen3__rigidbody__Joints
#define SWIG_RIGIDBODY_GEN_COORD SWIGTYPE_p_BiorbdEigen3__rigidbody__GeneralizedCoordinates
#define SWIG_RIGIDBODY_GEN_VEL SWIGTYPE_p_BiorbdEigen3__rigidbody__GeneralizedVelocity
#define SWIG_RIGIDBODY_GEN_ACC SWIGTYPE_p_BiorbdEigen3__rigidbody__GeneralizedAcceleration
#define SWIG_RIGIDBODY_GEN_TORQUE SWIGTYPE_p_BiorbdEigen3__rigidbody__GeneralizedTorque
#define SWIG_RIGIDBODY_MARKERS SWIGTYPE_p_BiorbdEigen3__rigidbody__Markers
#endif

// -- STRING --//
%typemap(typecheck, precedence=2300) BIORBD_NAMESPACE::utils::String &{
    void *argp1 = 0;
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIG_UTILS_STRING,  0  | 0)) && argp1) {
        // Test if it is a pointer to String already exists
        $1 = true;
    } else if( PyUnicode_Check($input) ) {
        // test if it is a string (python3 has unicode)
        $1 = true;
    } else {
        $1 = false;
    }
};
%typemap(in) BIORBD_NAMESPACE::utils::String &{
    void * argp1 = 0;
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIG_UTILS_STRING,  0  | 0)) && argp1) {
        // Recast the pointer
        $1 = reinterpret_cast< BIORBD_NAMESPACE::utils::String * >(argp1);
    } else if( PyUnicode_Check($input) ) {
        // Interpret the string
        $1 = new BIORBD_NAMESPACE::utils::String(PyUnicode_AsUTF8($input));
    } else {
        PyErr_SetString(PyExc_ValueError, "String must be a utils::String or string");
        SWIG_fail;
    }
};

// --- Path --- //
%typemap(typecheck, precedence=2310) BIORBD_NAMESPACE::utils::Path &{
    void *argp1 = 0;
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIG_UTILS_PATH,  0  | 0)) && argp1) {
        // Test if it is a pointer to Path already exists
        $1 = true;
    } else if( PyUnicode_Check($input) ) {
        // test if it is a string (python3 has unicode)
        $1 = true;
    } else {
        $1 = false;
    }
};
%typemap(in) BIORBD_NAMESPACE::utils::Path &{
    void * argp1 = 0;
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIG_UTILS_PATH,  0  | 0)) && argp1) {
        // Recast the pointer
        $1 = reinterpret_cast< BIORBD_NAMESPACE::utils::Path * >(argp1);
    } else if( PyUnicode_Check($input) ) {
        // Interpret the string
        $1 = new BIORBD_NAMESPACE::utils::Path(PyUnicode_AsUTF8($input));
    } else {
        PyErr_SetString(PyExc_ValueError, "Path must be a Path or string");
        SWIG_fail;
    }
};

// --- Joints --- //
%typemap(typecheck, precedence=2000) BIORBD_NAMESPACE::rigidbody::Joints &{
    void *argp1 = 0;
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIG_RIGIDBODY_JOINTS,  0  | 0)) && argp1) {
        // Test if it is a pointer to SWIG_RIGIDBODY_JOINTS already exists
        $1 = true;
    } else {
        $1 = false;
    }
}
%typemap(in) BIORBD_NAMESPACE::rigidbody::Joints &{
    void * argp1 = 0;
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIG_RIGIDBODY_JOINTS,  0  | 0)) && argp1) {
        // Recast the pointer
        $1 = reinterpret_cast< BIORBD_NAMESPACE::rigidbody::Joints * >(argp1);
    } else {
        PyErr_SetString(PyExc_ValueError,
                        "rigidbody::Joints must be a rigidbody::Joints");
        SWIG_fail;
    }
}

// --- Allows for calling MX as scalar --- //
%typemap(typecheck, precedence=2400) BIORBD_NAMESPACE::utils::Scalar& {
    void *argp1 = 0;
#ifdef BIORBD_USE_CASADI_MATH
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIGTYPE_p_casadi__MX,  0  | 0)) && argp1) {
        // Test if it is a pointer an MX
        casadi::MX *mx = reinterpret_cast<casadi::MX*>(argp1);
        if (mx->rows() == 1 && mx->columns() == 1){
            $1 = true;
        }
        else {
            $1 = false;
        }
    } else
#endif
    if ( PyArray_Check($input) ) {
        // test if it is a numpy array
        $1 = true;
    }
    else if (PyFloat_Check($input)) {
        // Test if it is a double pointer
        $1 = true;
    } else if (PyLong_Check($input)) {
        // Test if it is a double pointer
        $1 = true;
    } else {
        $1 = false;
    }
};
%typemap(in) BIORBD_NAMESPACE::utils::Scalar& {
    void * argp1 = 0;
#ifdef BIORBD_USE_CASADI_MATH
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIGTYPE_p_casadi__MX,  0  | 0)) && argp1) {
        // Recast the pointer
        try{
            $1 = new BIORBD_NAMESPACE::utils::Scalar(*reinterpret_cast<casadi::MX*>(argp1));
        } catch (...){
            PyErr_SetString(PyExc_ValueError, "Scalar must be a 1x1 array or a float");
            SWIG_fail;
        }
    } else
#endif
    if( PyArray_Check($input) ) {
        // Get dimensions of the data
        int        ndim     = PyArray_NDIM    ((PyArrayObject*)$input);
        npy_intp*  dims     = PyArray_DIMS    ((PyArrayObject*)$input);

        // Cast the vector
        PyObject *data = PyArray_FROM_OTF((PyObject*)$input, NPY_DOUBLE, NPY_ARRAY_IN_ARRAY);
        if (ndim == 1 ) {
            unsigned int scalar_dim0 = static_cast<unsigned int>(dims[0]);
            if (scalar_dim0 != 1){
                PyErr_SetString(PyExc_ValueError,
                                "Scalar must be a 1x1 array or a float");
                SWIG_fail;
            }

            // Copy the actual data
            $1 = new BIORBD_NAMESPACE::utils::Scalar(*(double*)PyArray_GETPTR1((PyArrayObject*)data, 0));
        }
        else if (ndim == 2) {
            unsigned int scalar_dim0(static_cast<unsigned int>(dims[0]));
            unsigned int scalar_dim1(static_cast<unsigned int>(dims[1]));
            if (scalar_dim0 != 1 && scalar_dim1 != 1){
                PyErr_SetString(PyExc_ValueError,
                                "Scalar must be a 1x1 array or a float");
                SWIG_fail;
            }

            // Copy the actual data
            $1 = new BIORBD_NAMESPACE::utils::Scalar(*(double*)PyArray_GETPTR2((PyArrayObject*)data, 0, 0));
        }
        else {
            PyErr_SetString(PyExc_ValueError,
                            "Scalar must be a 1x1 array or a float");
            SWIG_fail;
        }
    }
    else if (PyFloat_Check($input)) {
        $1 = new BIORBD_NAMESPACE::utils::Scalar(PyFloat_AS_DOUBLE($input));
    }
    else if (PyLong_Check($input)) {
        $1 = new BIORBD_NAMESPACE::utils::Scalar(static_cast<double>(PyLong_AS_LONG($input)));
    }
    else {
        PyErr_SetString(PyExc_ValueError, "Scalar must be a 1x1 array or a float");
        SWIG_fail;
    }
};

#ifdef BIORBD_USE_CASADI_MATH
%extend BIORBD_NAMESPACE::utils::Scalar{
    casadi::MX to_mx(){
        return *dynamic_cast<casadi::MX*>($self);
    };
}
#endif

// --- Quaternion --- //
%extend BIORBD_NAMESPACE::utils::Quaternion{
#ifdef BIORBD_USE_CASADI_MATH
    casadi::MX to_mx(){
        return *dynamic_cast<casadi::MX*>($self);
    };
#else
    PyObject* to_array(){
        int nRows(1);
        int nCols(4);
        int nArraySize(2);
        npy_intp * arraySizes = new npy_intp[nArraySize];
        arraySizes[0] = nRows;
        arraySizes[1] = nCols;

        double * quat = new double[nRows*nCols];
        unsigned int k(0);
        for (unsigned int i = 0; i < static_cast<unsigned int>(nRows); ++i){
            for (unsigned int j = 0; j < static_cast<unsigned int>(nCols); ++j){
                quat[k] = (*$self)(j,i);
                ++k;
            }
        }
        PyObject* output = PyArray_SimpleNewFromData(nArraySize,arraySizes,NPY_DOUBLE, quat);
        PyArray_ENABLEFLAGS((PyArrayObject *)output, NPY_ARRAY_OWNDATA);
		delete[] arraySizes;
        return output;
    };
#endif
}

// --- Matrix --- //
%extend BIORBD_NAMESPACE::utils::Matrix{
#ifdef BIORBD_USE_CASADI_MATH
    casadi::MX to_mx(){
        return *dynamic_cast<casadi::MX*>($self);
    };
#else
    PyObject* to_array(){
        int nRows(static_cast<int>($self->rows()));
        int nCols(static_cast<int>($self->cols()));
        int nArraySize(2);
        npy_intp * arraySizes = new npy_intp[nArraySize];
        arraySizes[0] = nRows;
        arraySizes[1] = nCols;

        double * matrix = new double[nRows*nCols];
        unsigned int k(0);
        for (unsigned int i = 0; i < static_cast<unsigned int>(nRows); ++i){
            for (unsigned int j = 0; j < static_cast<unsigned int>(nCols); ++j){
                matrix[k] = (*$self)(i, j);
                ++k;
            }
        }
        PyObject* output = PyArray_SimpleNewFromData(nArraySize,arraySizes,NPY_DOUBLE, matrix);
        PyArray_ENABLEFLAGS((PyArrayObject *)output, NPY_ARRAY_OWNDATA);
		delete[] arraySizes;
        return output;
    };
	
	BIORBD_NAMESPACE::utils::Matrix multiply (const BIORBD_NAMESPACE::utils::Matrix& other){
		return (*$self) * other;
	}
#endif
}

%typemap(typecheck, precedence=2155) Eigen::Matrix3d & {
#ifdef BIORBD_USE_CASADI_MATH
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIGTYPE_p_casadi__MX,  0  | 0)) && argp1) {
#else
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIG_UTILS_MATRIX3D,  0  | 0)) && argp1) {
#endif
    // Test if it is a pointer an MX or Vector
        $1 = true;
    }
    else if( PyArray_Check($input) ) {
        // test if it is a numpy array
        $1 = true;
    }
    else {
        $1 = false;
    }
}
%typemap(in) BIORBD_NAMESPACE::utils::Matrix3d & {
    void * argp1 = 0;
#ifdef BIORBD_USE_CASADI_MATH
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIGTYPE_p_casadi__MX,  0  | 0)) && argp1) {
        $1 = new BIORBD_NAMESPACE::utils::Matrix3d(*reinterpret_cast<casadi::MX*>(argp1));
#else
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIG_UTILS_MATRIX3D,  0  | 0)) && argp1) {
        // Recast the pointer
        $1 = reinterpret_cast< BIORBD_NAMESPACE::utils::Matrix3d * >(argp1);
#endif
    } else if( PyArray_Check($input) ) {
        // Get dimensions of the data::
        int        ndim     = PyArray_NDIM    ((PyArrayObject*)$input);
        npy_intp*  dims     = PyArray_DIMS    ((PyArrayObject*)$input);

        // Dimension controls
        if (ndim != 2 || dims[0] != 3 || dims[1] != 3){
            PyErr_SetString(PyExc_ValueError, "utils::Matrix3d must be a 3x3 matrix");
            SWIG_fail;
        }

        // Cast the vector
        PyObject *data = PyArray_FROM_OTF((PyObject*)$input, NPY_DOUBLE, NPY_ARRAY_IN_ARRAY);
        // Copy the actual data
        $1 = new BIORBD_NAMESPACE::utils::Matrix3d();
        for (unsigned int i=0; i<3; ++i){
            for (unsigned int j=0; j<3; ++j){
                (*$1)(i, j) = *(double*)PyArray_GETPTR2((PyArrayObject*)data, i, j);
            }
        }
    } else {
        PyErr_SetString(PyExc_ValueError,
                        "utils::Matrix3d must be a 3x3 matrix when using a numpy array");
        SWIG_fail;
    }
};
%extend BIORBD_NAMESPACE::utils::Matrix3d{
#ifdef BIORBD_USE_CASADI_MATH
    casadi::MX to_mx(){
        return *dynamic_cast<casadi::MX*>($self);
    };
#else
    PyObject* to_array(){
        int nRows($self->rows());
        int nCols($self->cols());
        int nArraySize(2);
        npy_intp * arraySizes = new npy_intp[nArraySize];
        if (nRows != 3 || nCols != 3)
        {
            PyErr_SetString(PyExc_ValueError, "Matrix3d must be a 3x3 matrix");
        }
        arraySizes[0] = nRows;
        arraySizes[1] = nCols;

        double * matrix = new double[nRows*nCols];
        unsigned int k(0);
        for (unsigned int i = 0; i < static_cast<unsigned int>(nRows); ++i){
            for (unsigned int j = 0; j < static_cast<unsigned int>(nCols); ++j){
                matrix[k] = (*$self)(i, j);
                ++k;
            }
        }
        PyObject* output = PyArray_SimpleNewFromData(nArraySize,arraySizes,NPY_DOUBLE, matrix);
        PyArray_ENABLEFLAGS((PyArrayObject *)output, NPY_ARRAY_OWNDATA);
		delete[] arraySizes;
        return output;
    };
	
	BIORBD_NAMESPACE::utils::Matrix3d multiply (const BIORBD_NAMESPACE::utils::Matrix3d& other){
		return (*$self) * other;
	}
#endif
}

#ifndef BIORBD_USE_CASADI_MATH
%typemap(typecheck, precedence=2155) Eigen::Matrix4d & {
    if( PyArray_Check($input) ) {
        // test if it is a numpy array
        $1 = true;
    } else {
        $1 = false;
    }
}
%typemap(in) Eigen::Matrix4d & {
    if( PyArray_Check($input) ) {
        // Get dimensions of the data::
        int        ndim     = PyArray_NDIM    ((PyArrayObject*)$input);
        npy_intp*  dims     = PyArray_DIMS    ((PyArrayObject*)$input);

        // Dimension controls
        if (ndim != 2 ){
            PyErr_SetString(PyExc_ValueError, "Eigen::Matrix4d must be a 4x4 matrix");
            SWIG_fail;
        }
        if (dims[0] != 4 || dims[1] != 4){
            PyErr_SetString(PyExc_ValueError, "Eigen::Matrix4d must be a 4x4 matrix");
            SWIG_fail;
        }

        // Cast the vector
        PyObject *data = PyArray_FROM_OTF((PyObject*)$input, NPY_DOUBLE, NPY_ARRAY_IN_ARRAY);
        // Copy the actual data
        $1 = new Eigen::Matrix4d();
        for (unsigned int i=0; i<4; ++i){
            for (unsigned int j=0; j<4; ++j){
                (*$1)(i, j) = *(double*)PyArray_GETPTR2((PyArrayObject*)data, i, j);
            }
        }
    } else {
        PyErr_SetString(PyExc_ValueError,
                        "Eigen::Matrix4d must be a 4x4 matrix "
                        "when using a numpy array");
        SWIG_fail;
    }
};
#endif

// --- Vector --- //
%extend BIORBD_NAMESPACE::utils::Vector{
#ifdef BIORBD_USE_CASADI_MATH
    casadi::MX to_mx(){
        return *dynamic_cast<casadi::MX*>($self);
    };
#else
    PyObject* to_array(){
        int nElements(static_cast<int>($self->size()));
        int nArraySize(1);
        npy_intp * arraySizes = new npy_intp[nArraySize];
        arraySizes[0] = nElements;

        double * vect = new double[nElements];
        for (unsigned int i = 0; i < static_cast<unsigned int>(nElements); ++i){
            vect[i] = (*$self)(i);
        }
        PyObject* output = PyArray_SimpleNewFromData(nArraySize,arraySizes,NPY_DOUBLE, vect);
        PyArray_ENABLEFLAGS((PyArrayObject *)output, NPY_ARRAY_OWNDATA);
		delete[] arraySizes;
        return output;
    };
#endif
}
%typemap(typecheck, precedence=2150) BIORBD_NAMESPACE::utils::Vector & {
    void *argp1 = 0;
#ifdef BIORBD_USE_CASADI_MATH
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIGTYPE_p_casadi__MX,  0  | 0)) && argp1) {
#else
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIG_UTILS_VECTOR,  0  | 0)) && argp1) {
#endif
    // Test if it is a pointer an MX or Vector
        $1 = true;
    }
    else if( PyArray_Check($input) ) {
        // test if it is a numpy array
        $1 = true;
    }
    else {
        $1 = false;
    }
}
%typemap(in) BIORBD_NAMESPACE::utils::Vector & {
    void * argp1 = 0;
#ifdef BIORBD_USE_CASADI_MATH
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIGTYPE_p_casadi__MX,  0  | 0)) && argp1) {
        $1 = new BIORBD_NAMESPACE::utils::Vector(*reinterpret_cast<casadi::MX*>(argp1));
#else
    if (SWIG_IsOK(
                SWIG_ConvertPtr($input, &argp1,
                                SWIG_UTILS_VECTOR,  0  | 0))
            && argp1) {
        // Recast the pointer
        $1 = reinterpret_cast< BIORBD_NAMESPACE::utils::Vector * >(argp1);
#endif
    } else if( PyArray_Check($input) ) {
        // Get dimensions of the data::
        int        ndim     = PyArray_NDIM    ((PyArrayObject*)$input);
        npy_intp*  dims     = PyArray_DIMS    ((PyArrayObject*)$input);

        // Dimension controls
        if (ndim != 1 ){
            PyErr_SetString(PyExc_ValueError, "Vector must be a numpy vector");
            SWIG_fail;
        }

        // Cast the vector
        PyObject *data = PyArray_FROM_OTF((PyObject*)$input, NPY_DOUBLE, NPY_ARRAY_IN_ARRAY);
        // Copy the actual data
        unsigned int n(static_cast<unsigned int>(dims[0]));
        $1 = new BIORBD_NAMESPACE::utils::Vector(n);
        for (unsigned int i=0; i<n; ++i)
            (*$1)[i] = *(double*)PyArray_GETPTR1((PyArrayObject*)data, i);

    } else {
        PyErr_SetString(PyExc_ValueError,
                        "Vector must be a one dimension "
                        "vector when using a numpy array");
        SWIG_fail;
    }
};

// --- GeneralizedCoordinates --- //
%typemap(typecheck, precedence=2100)
BIORBD_NAMESPACE::rigidbody::GeneralizedCoordinates & {
    void *argp1 = 0;
    if(SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIG_RIGIDBODY_GEN_COORD,  0  | 0)) && argp1){
            $1 = true;
        }
#ifdef BIORBD_USE_CASADI_MATH
    else if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIGTYPE_p_casadi__MX,  0  | 0)) && argp1) {
        // Test if it is a pointer to
        // SWIG_RIGIDBODY_GEN_COORD already exists
        $1 = true;
    }
#endif
    else if( PyArray_Check($input) ) {
        // test if it is a numpy array
        $1 = true;
    }
    else {
        $1 = false;
    }
}
%typemap(in) BIORBD_NAMESPACE::rigidbody::GeneralizedCoordinates & {
    void * argp1 = 0;
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1,SWIG_RIGIDBODY_GEN_COORD, 0  | 0)) && argp1) {
        $1 = reinterpret_cast< BIORBD_NAMESPACE::rigidbody::GeneralizedCoordinates * >(argp1);
    }
#ifdef BIORBD_USE_CASADI_MATH
    else if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIGTYPE_p_casadi__MX,  0  | 0)) && argp1) {
        $1 = new BIORBD_NAMESPACE::rigidbody::GeneralizedCoordinates(*reinterpret_cast<casadi::MX*>(argp1));
    }
#endif
    else if( PyArray_Check($input) ) {
        // Get dimensions of the data
        int        ndim     = PyArray_NDIM    ((PyArrayObject*)$input);
        npy_intp*  dims     = PyArray_DIMS    ((PyArrayObject*)$input);

        // Dimension controls
        if (ndim != 1 ){
            PyErr_SetString(PyExc_ValueError,
                            "GeneralizedCoordinates must be a one dimension "
                            "vector when using a numpy array");
            SWIG_fail;
        }

        // Cast the vector
        PyObject *data = PyArray_FROM_OTF((PyObject*)$input, NPY_DOUBLE, NPY_ARRAY_IN_ARRAY);
        // Copy the actual data
        unsigned int nQ(static_cast<unsigned int>(dims[0]));
        $1 = new BIORBD_NAMESPACE::rigidbody::GeneralizedCoordinates(nQ);
        for (unsigned int q=0; q<nQ; ++q){
            (*$1)[q] = *(double*)PyArray_GETPTR1((PyArrayObject*)data, q);
        }
    }
};
%typemap(typecheck, precedence=2101) BIORBD_NAMESPACE::rigidbody::GeneralizedCoordinates * {
    void *argp1 = 0;
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1,SWIG_RIGIDBODY_GEN_COORD, 0  | 0)) && argp1) {
        $1 = true;
    }
#ifdef BIORBD_USE_CASADI_MATH
    else if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIGTYPE_p_casadi__MX,  0  | 0)) && argp1) {
            $1 = true;
    }
#endif
    else if( PyArray_Check($input) ) {
        // test if it is a numpy array
        $1 = true;
    }
    else if ($input == Py_None){
        $1 = true;
    }
    else{
        $1 = false;
    }
}
%typemap(in) BIORBD_NAMESPACE::rigidbody::GeneralizedCoordinates * {
    void * argp1 = 0;

    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1,SWIG_RIGIDBODY_GEN_COORD, 0  | 0)) && argp1) {
        $1 = reinterpret_cast< BIORBD_NAMESPACE::rigidbody::GeneralizedCoordinates * >(argp1);
    }
#ifdef BIORBD_USE_CASADI_MATH
    else if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIGTYPE_p_casadi__MX,  0  | 0)) && argp1) {
        $1 = new BIORBD_NAMESPACE::rigidbody::GeneralizedCoordinates(*reinterpret_cast<casadi::MX*>(argp1));
    }
#endif
    else if( PyArray_Check($input) ) {
        // Get dimensions of the data
        int        ndim     = PyArray_NDIM    ((PyArrayObject*)$input);
        npy_intp*  dims     = PyArray_DIMS    ((PyArrayObject*)$input);

        // Dimension controls
        if (ndim != 1 ){
            PyErr_SetString(PyExc_ValueError,
                            "GeneralizedCoordinates must be a one dimension "
                            "vector when using a numpy array");
            SWIG_fail;
        }

        // Cast the vector
        PyObject *data = PyArray_FROM_OTF((PyObject*)$input, NPY_DOUBLE, NPY_ARRAY_IN_ARRAY);
        // Copy the actual data
        unsigned int nQ(static_cast<unsigned int>(dims[0]));
        $1 = new BIORBD_NAMESPACE::rigidbody::GeneralizedCoordinates(nQ);
        for (unsigned int q=0; q<nQ; ++q){
            (*$1)[q] = *(double*)PyArray_GETPTR1((PyArrayObject*)data, q);
        }
    }
    else if ($input == Py_None) {
        $1 = nullptr;
    }
};

// --- GeneralizedVelocity --- //
%typemap(typecheck, precedence=2102)
BIORBD_NAMESPACE::rigidbody::GeneralizedVelocity & {
    void *argp1 = 0;
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIG_RIGIDBODY_GEN_VEL, 0  | 0)) && argp1) {
        $1 = true;
    }
#ifdef BIORBD_USE_CASADI_MATH
    else if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIGTYPE_p_casadi__MX,  0  | 0)) && argp1) {
        $1 = true;
    }
#endif
    else if(SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIG_RIGIDBODY_GEN_VEL,  0  | 0)) && argp1){
        $1 = true;
    }
    else if( PyArray_Check($input) ) {
        // test if it is a numpy array
        $1 = true;
    }
    else {
        $1 = false;
    }
}
%typemap(in) BIORBD_NAMESPACE::rigidbody::GeneralizedVelocity & {
    void * argp1 = 0;

    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIG_RIGIDBODY_GEN_VEL, 0  | 0)) && argp1) {
        $1 = reinterpret_cast< BIORBD_NAMESPACE::rigidbody::GeneralizedVelocity * >(argp1);
    }
#ifdef BIORBD_USE_CASADI_MATH
    else if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIGTYPE_p_casadi__MX,  0  | 0)) && argp1) {
        $1 = new BIORBD_NAMESPACE::rigidbody::GeneralizedVelocity(*reinterpret_cast<casadi::MX*>(argp1));
    }
#endif
    else if( PyArray_Check($input) ) {
        // Get dimensions of the data
        int        ndim     = PyArray_NDIM    ((PyArrayObject*)$input);
        npy_intp*  dims     = PyArray_DIMS    ((PyArrayObject*)$input);

        // Dimension controls
        if (ndim != 1 ){
            PyErr_SetString(PyExc_ValueError,
                            "GeneralizedVelocity must be a one dimension "
                            "vector when using a numpy array");
            SWIG_fail;
        }

        // Cast the vector
        PyObject *data = PyArray_FROM_OTF((PyObject*)$input, NPY_DOUBLE, NPY_ARRAY_IN_ARRAY);
        // Copy the actual data
        unsigned int nQdot(static_cast<unsigned int>(dims[0]));
        $1 = new BIORBD_NAMESPACE::rigidbody::GeneralizedVelocity(nQdot);
        for (unsigned int qdot=0; qdot<nQdot; ++qdot){
            (*$1)[qdot] = *(double*)PyArray_GETPTR1((PyArrayObject*)data, qdot);
        }
    }
};
// --- GeneralizedVelocity --- //
%typemap(typecheck, precedence=2103)
BIORBD_NAMESPACE::rigidbody::GeneralizedVelocity * {
    void *argp1 = 0;
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1,SWIG_RIGIDBODY_GEN_VEL, 0  | 0)) && argp1) {
        $1 = true;
    }
#ifdef BIORBD_USE_CASADI_MATH
    else if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIGTYPE_p_casadi__MX,  0  | 0)) && argp1) {
        $1 = true;
    }
#endif
    else if( PyArray_Check($input) ) {
        // test if it is a numpy array
        $1 = true;
    }
    else if ($input == Py_None){
        $1 = true;
    }
    else {
        $1 = false;
    }
}
%typemap(in) BIORBD_NAMESPACE::rigidbody::GeneralizedVelocity * {
    void * argp1 = 0;
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIG_RIGIDBODY_GEN_VEL, 0  | 0)) && argp1) {
        $1 = reinterpret_cast< BIORBD_NAMESPACE::rigidbody::GeneralizedVelocity * >(argp1);
    }
#ifdef BIORBD_USE_CASADI_MATH
    else if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIGTYPE_p_casadi__MX,  0  | 0)) && argp1) {
        $1 = new BIORBD_NAMESPACE::rigidbody::GeneralizedVelocity(*reinterpret_cast<casadi::MX*>(argp1));
    }
#endif
    else if( PyArray_Check($input) ) {
        // Get dimensions of the data
        int        ndim     = PyArray_NDIM    ((PyArrayObject*)$input);
        npy_intp*  dims     = PyArray_DIMS    ((PyArrayObject*)$input);

        // Dimension controls
        if (ndim != 1 ){
            PyErr_SetString(PyExc_ValueError,
                            "GeneralizedVelocity must be a one dimension "
                            "vector when using a numpy array");
            SWIG_fail;
        }

        // Cast the vector
        PyObject *data = PyArray_FROM_OTF((PyObject*)$input, NPY_DOUBLE, NPY_ARRAY_IN_ARRAY);
        // Copy the actual data
        unsigned int nQdot(static_cast<unsigned int>(dims[0]));
        $1 = new BIORBD_NAMESPACE::rigidbody::GeneralizedVelocity(nQdot);
        for (unsigned int qdot=0; qdot<nQdot; ++qdot){
            (*$1)[qdot] = *(double*)PyArray_GETPTR1((PyArrayObject*)data, qdot);
        }
    }
    else if ($input == Py_None){
        $1 = nullptr;
    }
};

// --- GeneralizedAcceleration --- //
%typemap(typecheck, precedence=2106)
BIORBD_NAMESPACE::rigidbody::GeneralizedAcceleration & {
    void *argp1 = 0;
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIG_RIGIDBODY_GEN_ACC, 0  | 0)) && argp1) {
        $1 = true;
    }
#ifdef BIORBD_USE_CASADI_MATH
    else if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIGTYPE_p_casadi__MX,  0  | 0)) && argp1) {
        $1 = true;
    }
#endif
    else if( PyArray_Check($input) ) {
        // test if it is a numpy array
        $1 = true;
    }
    else {
        $1 = false;
    }
}
%typemap(in) BIORBD_NAMESPACE::rigidbody::GeneralizedAcceleration & {
    void * argp1 = 0;
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIG_RIGIDBODY_GEN_ACC, 0  | 0)) && argp1) {
        $1 = reinterpret_cast< BIORBD_NAMESPACE::rigidbody::GeneralizedAcceleration * >(argp1);
    }
#ifdef BIORBD_USE_CASADI_MATH
    else if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIGTYPE_p_casadi__MX,  0  | 0)) && argp1) {
        $1 = new BIORBD_NAMESPACE::rigidbody::GeneralizedAcceleration(*reinterpret_cast<casadi::MX*>(argp1));
    }
#endif
    else if( PyArray_Check($input) ) {
        // Get dimensions of the data
        int        ndim     = PyArray_NDIM    ((PyArrayObject*)$input);
        npy_intp*  dims     = PyArray_DIMS    ((PyArrayObject*)$input);

        // Dimension controls
        if (ndim != 1 ){
            PyErr_SetString(PyExc_ValueError,
                            "GeneralizedAcceleration must be a one dimension "
                            "vector when using a numpy array");
            SWIG_fail;
        }

        // Cast the vector
        PyObject *data = PyArray_FROM_OTF((PyObject*)$input, NPY_DOUBLE, NPY_ARRAY_IN_ARRAY);
        // Copy the actual data
        unsigned int nQddot(static_cast<unsigned int>(dims[0]));
        $1 = new BIORBD_NAMESPACE::rigidbody::GeneralizedAcceleration(nQddot);
        for (unsigned int qddot=0; qddot<nQddot; ++qddot){
            (*$1)[qddot] = *(double*)PyArray_GETPTR1((PyArrayObject*)data, qddot);
        }
    }
};
// --- GeneralizedAcceleration --- //
%typemap(typecheck, precedence=2105)
BIORBD_NAMESPACE::rigidbody::GeneralizedAcceleration * {
    void *argp1 = 0;
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIG_RIGIDBODY_GEN_ACC, 0  | 0)) && argp1) {
        $1 = true;
    }
#ifdef BIORBD_USE_CASADI_MATH
    else if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIGTYPE_p_casadi__MX,  0  | 0)) && argp1) {
        $1 = true;
    }
#endif
    else if( PyArray_Check($input) ) {
        // test if it is a numpy array
        $1 = true;
    }
    else if ($input == Py_None){
        $1 = true;
    }
    else {
        $1 = false;
    }
}
%typemap(in) BIORBD_NAMESPACE::rigidbody::GeneralizedAcceleration * {
    void * argp1 = 0;
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIG_RIGIDBODY_GEN_ACC, 0  | 0)) && argp1) {
        $1 = reinterpret_cast< BIORBD_NAMESPACE::rigidbody::GeneralizedAcceleration * >(argp1);
    }
#ifdef BIORBD_USE_CASADI_MATH
    else if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIGTYPE_p_casadi__MX,  0  | 0)) && argp1) {
        $1 = new BIORBD_NAMESPACE::rigidbody::GeneralizedAcceleration(*reinterpret_cast<casadi::MX*>(argp1));
    }
#endif
    else if( PyArray_Check($input) ) {
        // Get dimensions of the data
        int        ndim     = PyArray_NDIM    ((PyArrayObject*)$input);
        npy_intp*  dims     = PyArray_DIMS    ((PyArrayObject*)$input);

        // Dimension controls
        if (ndim != 1 ){
            PyErr_SetString(PyExc_ValueError,
                            "GeneralizedAcceleration must be a one dimension "
                            "vector when using a numpy array");
            SWIG_fail;
        }

        // Cast the vector
        PyObject *data = PyArray_FROM_OTF((PyObject*)$input, NPY_DOUBLE, NPY_ARRAY_IN_ARRAY);
        // Copy the actual data
        unsigned int nQddot(static_cast<unsigned int>(dims[0]));
        $1 = new BIORBD_NAMESPACE::rigidbody::GeneralizedAcceleration(nQddot);
        for (unsigned int qddot=0; qddot<nQddot; ++qddot){
            (*$1)[qddot] = *(double*)PyArray_GETPTR1((PyArrayObject*)data, qddot);
        }
    }
    else if ($input == Py_None){
        $1 = nullptr;
    }
};

// --- GeneralizedTorque --- //
%typemap(typecheck, precedence=2110) BIORBD_NAMESPACE::rigidbody::GeneralizedTorque &{
    void *argp1 = 0;
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIG_RIGIDBODY_GEN_TORQUE,  0  | 0)) && argp1) {
        $1 = true;
    }
#ifdef BIORBD_USE_CASADI_MATH
    else if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIGTYPE_p_casadi__MX,  0  | 0)) && argp1) {
        $1 = true;
    }
#endif
    else if( PyArray_Check($input) ) {
        // test if it is a numpy array
        $1 = true;
    }
    else {
        $1 = false;
    }
}
%typemap(in) BIORBD_NAMESPACE::rigidbody::GeneralizedTorque &{
    void * argp1 = 0;
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIG_RIGIDBODY_GEN_TORQUE,  0  | 0)) && argp1) {
        $1 = reinterpret_cast< BIORBD_NAMESPACE::rigidbody::GeneralizedTorque * >(argp1);
    }
#ifdef BIORBD_USE_CASADI_MATH
    else if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIGTYPE_p_casadi__MX,  0  | 0)) && argp1) {
        $1 = new BIORBD_NAMESPACE::rigidbody::GeneralizedTorque(*reinterpret_cast<casadi::MX*>(argp1));
    }
#endif
    else if( PyArray_Check($input) ) {
        // Get dimensions of the data
        int        ndim     = PyArray_NDIM    ((PyArrayObject*)$input);
        npy_intp*  dims     = PyArray_DIMS    ((PyArrayObject*)$input);

        // Dimension controls (has to be a vector)
        if (ndim != 1 ){
            PyErr_SetString(PyExc_ValueError,
                            "GeneralizedTorque must be a one dimension "
                            "vector when using a numpy array");
            SWIG_fail;
        }

        // Cast the vector
        PyObject *data = PyArray_FROM_OTF((PyObject*)$input, NPY_DOUBLE, NPY_ARRAY_IN_ARRAY);

        // Copy the actual data
        unsigned int nGeneralizedTorque(static_cast<unsigned int>(dims[0]));
        $1 = new BIORBD_NAMESPACE::rigidbody::GeneralizedTorque(nGeneralizedTorque);
        for (unsigned int GeneralizedTorque=0; GeneralizedTorque<nGeneralizedTorque; ++GeneralizedTorque)
            (*$1)[GeneralizedTorque] = *(double*)PyArray_GETPTR1((PyArrayObject*)data, GeneralizedTorque);

    }
    else {
        PyErr_SetString(PyExc_ValueError,
                        "GeneralizedTorque must be a "
                        "GeneralizedTorque or numpy vector");
        SWIG_fail;
    }
};

#ifndef BIORBD_USE_CASADI_MATH
// --- BIORBD_NAMESPACE::rigidbody::Markers --- //
%typemap(typecheck, precedence=2200) BIORBD_NAMESPACE::rigidbody::Markers &{
    void *argp1 = 0;
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIG_RIGIDBODY_MARKERS,  0  | 0)) && argp1) {
        // Test if it is a pointer to SWIG_RIGIDBODY_MARKERS already exists
        $1 = true;
    } else {
        $1 = false;
    }
}
%typemap(in) BIORBD_NAMESPACE::rigidbody::Markers &{
    void * argp1 = 0;
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIG_RIGIDBODY_MARKERS,  0  | 0)) && argp1) {
        // Recast the pointer
        $1 = reinterpret_cast< BIORBD_NAMESPACE::rigidbody::Markers * >(argp1);
    } else {
        PyErr_SetString(PyExc_ValueError,
                        "BIORBD_NAMESPACE::rigidbody::Markers must be "
                        "a BIORBD_NAMESPACE::rigidbody::Markers");
        SWIG_fail;
    }
}
#endif

// --- Vector3d --- //
%typemap(typecheck, precedence=2130)
BIORBD_NAMESPACE::utils::Vector3d &{
    void *argp1 = 0;
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIG_UTILS_NODE,  0  | 0))
            || SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIG_UTILS_VECTOR3D,  0  | 0))
            && argp1) {
        // Test if it is a pointer to SWIG_UTILS_NODE already exists
        $1 = true;
     }
#ifdef BIORBD_USE_CASADI_MATH
    else if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIGTYPE_p_casadi__MX,  0  | 0)) && argp1) {
        // Test if it is a pointer to
        // SWIG_UTILS_VECTOR3d already exists
        $1 = true;
    }
#endif
    else if( PyArray_Check($input) ) {
        // test if it is a numpy array
        
        $1 = true;
    } else {
        $1 = false;
    }
}
%typemap(in) BIORBD_NAMESPACE::utils::Vector3d &{
    void * argp1 = 0;
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIG_UTILS_NODE,  0  | 0))
            || SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIG_UTILS_VECTOR3D,  0  | 0))
            && argp1) {
        // Recast the pointer
        $1 = reinterpret_cast< BIORBD_NAMESPACE::utils::Vector3d * >(argp1);
     }
#ifdef BIORBD_USE_CASADI_MATH
    else if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIGTYPE_p_casadi__MX,  0  | 0)) && argp1) {
        $1 = new BIORBD_NAMESPACE::utils::Vector3d(BIORBD_NAMESPACE::utils::Vector(*reinterpret_cast<casadi::MX*>(argp1)));
    }
#endif
    else if( PyArray_Check($input) ) {
        // Get dimensions of the data
        int        ndim     = PyArray_NDIM    ((PyArrayObject*)$input);
        npy_intp*  dims     = PyArray_DIMS    ((PyArrayObject*)$input);

        // Dimension controls
        if (ndim != 1 && (dims[0] < 3 || dims[0] > 4)){
            PyErr_SetString(PyExc_ValueError, "Node must be a numpy 3d vector");
            SWIG_fail;
        }
        // Cast the vector
        PyObject *data = PyArray_FROM_OTF((PyObject*)$input, NPY_DOUBLE, NPY_ARRAY_IN_ARRAY);

        // Copy the actual data
        $1 = new BIORBD_NAMESPACE::utils::Vector3d(0, 0, 0);
        for (unsigned int i=0; i<3; ++i)
            (*$1)[i] = *(double*)PyArray_GETPTR1((PyArrayObject*)data, i);

    } else {
        PyErr_SetString(PyExc_ValueError, "Node must be a Node or numpy vector");
        SWIG_fail;
    }
};

%extend BIORBD_NAMESPACE::utils::Vector3d{
#ifdef BIORBD_USE_CASADI_MATH
    casadi::MX to_mx(){
        return *dynamic_cast<casadi::MX*>($self);
    };
#else
    PyObject* to_array(){
        int nArraySize(1);
        npy_intp * arraySizes = new npy_intp[nArraySize];
        arraySizes[0] = 3;

        double * node = new double[3];
        for (unsigned int i=0; i<3; ++i){
            node[i] = (*$self)(i);
        }
        PyObject* output = PyArray_SimpleNewFromData(nArraySize,arraySizes,NPY_DOUBLE, node);
        PyArray_ENABLEFLAGS((PyArrayObject *)output, NPY_ARRAY_OWNDATA);
		delete[] arraySizes;
        return output;
    }
#endif
};

// --- Spatial Vector --- //
%extend BIORBD_NAMESPACE::utils::SpatialVector{
#ifdef BIORBD_USE_CASADI_MATH
    casadi::MX to_mx(){
        return *dynamic_cast<casadi::MX*>($self);
    };
#else
    PyObject* to_array(){
        int nArraySize(1);
        npy_intp * arraySizes = new npy_intp[nArraySize];
        arraySizes[0] = 6;

        double * node = new double[6];
        for (unsigned int i=0; i<6; ++i){
            node[i] = (*$self)(i);
        }
        PyObject* output = PyArray_SimpleNewFromData(nArraySize,arraySizes,NPY_DOUBLE, node);
        PyArray_ENABLEFLAGS((PyArrayObject *)output, NPY_ARRAY_OWNDATA);
		delete[] arraySizes;
        return output;
    }
#endif
};
%typemap(typecheck, precedence=2010) BIORBD_NAMESPACE::utils::SpatialVector &{
    void *argp1 = 0;
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIG_UTILS_SPATIAL_VECTOR,  0  | 0)) && argp1) {
        $1 = true;
    }
#ifdef BIORBD_USE_CASADI_MATH
    else if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIGTYPE_p_casadi__MX,  0  | 0)) && argp1) {
        $1 = true;
    }
#endif
    else if( PyArray_Check($input) ) {
        // test if it is a numpy array
        $1 = true;
    }
    else {
        $1 = false;
    }
}
%typemap(in) BIORBD_NAMESPACE::utils::SpatialVector &{
    void * argp1 = 0;
    if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIG_UTILS_SPATIAL_VECTOR,  0  | 0)) && argp1) {
        $1 = reinterpret_cast< BIORBD_NAMESPACE::utils::SpatialVector * >(argp1);
    }
#ifdef BIORBD_USE_CASADI_MATH
    else if (SWIG_IsOK(SWIG_ConvertPtr($input, &argp1, SWIGTYPE_p_casadi__MX,  0  | 0)) && argp1) {
        $1 = new BIORBD_NAMESPACE::utils::SpatialVector(*reinterpret_cast<casadi::MX*>(argp1));
    }
#endif
    else if( PyArray_Check($input) ) {
        // Get dimensions of the data
        int        ndim     = PyArray_NDIM    ((PyArrayObject*)$input);
        npy_intp*  dims     = PyArray_DIMS    ((PyArrayObject*)$input);

        // Dimension controls (has to be a vector)
        if (ndim != 1 ){
            PyErr_SetString(PyExc_ValueError,
                            "SpatialVector must be a (6,) vector when using a numpy array");
            SWIG_fail;
        }

        // Cast the vector
        PyObject *data = PyArray_FROM_OTF((PyObject*)$input, NPY_DOUBLE, NPY_ARRAY_IN_ARRAY);

        // Copy the actual data
        unsigned int nSpatialVector(static_cast<unsigned int>(dims[0]));
        if (nSpatialVector != 6 ){
            PyErr_SetString(PyExc_ValueError,
                            "SpatialVector must be a (6,) vector when using a numpy array");
            SWIG_fail;
        }
        $1 = new BIORBD_NAMESPACE::utils::SpatialVector();
        for (unsigned int sv=0; sv<nSpatialVector; ++sv)
            (*$1)[sv] = *(double*)PyArray_GETPTR1((PyArrayObject*)data, sv);

    }
    else {
        PyErr_SetString(PyExc_ValueError,
                        "SpatialVector must be a SpatialVector or numpy vector");
        SWIG_fail;
    }
};

%extend BIORBD_NAMESPACE::utils::RotoTrans{
#ifdef BIORBD_USE_CASADI_MATH
    casadi::MX to_mx(){
        return *dynamic_cast<casadi::MX*>($self);
    };
#else
    PyObject* to_array(){
        int nArraySize(2);
        npy_intp * arraySizes = new npy_intp[nArraySize];
        arraySizes[0] = 4;
        arraySizes[1] = 4;

        double * values = new double[4*4];
        for (unsigned int i=0; i<4; ++i){
            for (unsigned int j=0; j<4; ++j){
                values[i*4+j] = (*$self)(j*4+i);
            }
        }
        PyObject* output = PyArray_SimpleNewFromData(nArraySize,arraySizes,NPY_DOUBLE, values);
        PyArray_ENABLEFLAGS((PyArrayObject *)output, NPY_ARRAY_OWNDATA);
		delete[] arraySizes;
        return output;
    }
	
	BIORBD_NAMESPACE::utils::RotoTrans multiply (const BIORBD_NAMESPACE::utils::RotoTrans& other){
		return Eigen::Matrix4d(*$self) * Eigen::Matrix4d(other);
	}
#endif
};

%extend BIORBD_NAMESPACE::rigidbody::IMU{
#ifdef BIORBD_USE_CASADI_MATH
    casadi::MX to_mx(){
        return *dynamic_cast<casadi::MX*>($self);
    };
#else
    PyObject* to_array(){
        int nArraySize(2);
        npy_intp * arraySizes = new npy_intp[nArraySize];
        arraySizes[0] = 4;
        arraySizes[1] = 4;

        double * values = new double[4*4];
        for (unsigned int i=0; i<4; ++i){
            for (unsigned int j=0; j<4; ++j){
                values[i*4+j] = (*$self)(j*4+i);
            }
        }
        PyObject* output = PyArray_SimpleNewFromData(nArraySize,arraySizes,NPY_DOUBLE, values);
        PyArray_ENABLEFLAGS((PyArrayObject *)output, NPY_ARRAY_OWNDATA);
		delete[] arraySizes;
        return output;
    }
#endif
};

%extend BIORBD_NAMESPACE::utils::Rotation{
#ifdef BIORBD_USE_CASADI_MATH
    casadi::MX to_mx(){
        return *dynamic_cast<casadi::MX*>($self);
    };
#else
    PyObject* to_array(){
        int nArraySize(2);
        npy_intp * arraySizes = new npy_intp[nArraySize];
        arraySizes[0] = 3;
        arraySizes[1] = 3;

        double * values = new double[3*3];
        for (unsigned int i=0; i<3; ++i){
            for (unsigned int j=0; j<3; ++j){
                values[i*3+j] = (*$self)(j*3+i);
            }
        }
        PyObject* output = PyArray_SimpleNewFromData(nArraySize,arraySizes,NPY_DOUBLE, values);
        PyArray_ENABLEFLAGS((PyArrayObject *)output, NPY_ARRAY_OWNDATA);
		delete[] arraySizes;
        return output;
    }
	
	BIORBD_NAMESPACE::utils::Rotation multiply (const BIORBD_NAMESPACE::utils::Rotation& other){
		return (*$self) * other;
	}
#endif
};

// Import the main swig interface
%include @CMAKE_CURRENT_BINARY_DIR@/../biorbd.i
